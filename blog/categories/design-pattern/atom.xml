<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design pattern | GeekerProbe]]></title>
  <link href="http://blog.wtlucky.com/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://blog.wtlucky.com/"/>
  <updated>2016-09-29T10:51:03+08:00</updated>
  <id>http://blog.wtlucky.com/</id>
  <author>
    <name><![CDATA[wtlucky ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[23种设计模式——策略模式]]></title>
    <link href="http://blog.wtlucky.com/blog/2013/03/31/strategy/"/>
    <updated>2013-03-31T20:46:00+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2013/03/31/strategy</id>
    <content type="html"><![CDATA[<p>这次介绍一下<code>策略模式（Strategy Pattern）</code>，相比之下是一种比较简单的模式。它也叫<code>政策模式（Policy Pattern）</code>。
<code>策略模式</code>使用的就是面向对象的<code>继承</code>和<code>多态</code>机制，其他的没有什么玄机。<code>策略模式</code>适合使用在：
1. 多个类只有在算法或行为上稍有不同的场景。
2. 算法需要自由切换的场景。
3. 需要屏蔽算法规则的场景。
使用<code>策略模式</code>当然也有需要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过4个，则需要考虑<code>混合模式</code>，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过<code>工厂方法模式</code>来实现策略类的声明。</p>

<p>下面我们就来具体讲解一下<code>策略模式</code>。</p>

<h4>策略模式定义</h4>

<p><code>Define a family of algorithms, encapsulate each one, and make them interchangeable.(定义一组算法，将每个算法都封装起来，并且是它们之间可以互换。)</code></p>

<!-- More -->


<h4>策略模式类图</h4>

<p>{% img <a href="https://oac67o3cg.qnssl.com/1475114575.png">https://oac67o3cg.qnssl.com/1475114575.png</a> %}</p>

<h4>策略模式说明</h4>

<ul>
<li>Context封装角色
它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在变化。</li>
<li>Strategy抽象策略角色
策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。</li>
<li>ConcreteStrategy具体策略角色
实现抽象策略中的操作，该类含有具体的算法。</li>
</ul>


<h4>策略模式优点</h4>

<ol>
<li>算法可以自由切换。</li>
<li>避免使用多重条件判断。</li>
<li>扩展性良好。</li>
</ol>


<h4>策略模式缺点</h4>

<ol>
<li>策略类数量增多
每一个策略都是一个类，复用的可能性很小，类数量增多。</li>
<li>所有的策略类都需要对外暴露
上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与<code>迪米特法则</code>是相违背的。</li>
</ol>


<h4>策略模式的objective-C实现</h4>

<p>{% codeblock Strategy lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>//定义接口
@protocol TransportStrategy <NSObject></p>

<ul>
<li>(void)travelling;</li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock ConcreteStrategy lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;TransportStrategy.h&rdquo;</h1>

<p>@interface Car : NSObject<TransportStrategy></p>

<p>@end</p>

<p>@implementation Car</p>

<ul>
<li>(void)travelling
{
  NSLog(@&ldquo;travelling by car.&rdquo;);
}</li>
</ul>


<p>@end</p>

<p>@interface Bicycle : NSObject<TransportStrategy></p>

<p>@end</p>

<p>@implementation Bicycle</p>

<ul>
<li>(void)travelling
{
  NSLog(@&ldquo;travelling by bicycle.&rdquo;);
}</li>
</ul>


<p>@end</p>

<p>@interface Train : NSObject<TransportStrategy></p>

<p>@end</p>

<p>@implementation Train</p>

<ul>
<li>(void)travelling
{
  NSLog(@&ldquo;travelling by train.&rdquo;);
}</li>
</ul>


<p>@end</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock Context lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;TransportStrategy.h&rdquo;</h1>

<p>@interface Person : NSObject</p>

<ul>
<li>(void)travel:(id<TransportStrategy>)transport;</li>
</ul>


<p>@end</p>

<p>@implementation Person</p>

<ul>
<li>(void)travel:(id<TransportStrategy>)transport
{
  [transport travelling];
}</li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock main lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;Car.h&rdquo;</h1>

<h1>import &ldquo;Bicycle.h&rdquo;</h1>

<h1>import &ldquo;Train.h&rdquo;</h1>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>int main(int argc, const char * argv[])
{</p>

<pre><code>@autoreleasepool {

    Car *car = [[Car alloc]init];
    Bicycle *bicycle = [[Bicycle alloc]init];
    Train *train = [[Train alloc]init];
    Person *person = [[Person alloc]init];

    [person travel:car];
    [person travel:bicycle];
    [person travel:train];


}
return 0;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23种设计模式——适配器模式]]></title>
    <link href="http://blog.wtlucky.com/blog/2013/03/23/adapter/"/>
    <updated>2013-03-23T14:13:00+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2013/03/23/adapter</id>
    <content type="html"><![CDATA[<p>今天要介绍的是<code>适配器模式（Adapter Pattern）</code>，适配器模式又叫做<code>变压器模式</code>，也叫做<code>包装模式（Wrapper）</code>，但是<code>包装模式</code>却不止一个，<code>装饰模式</code>也是<code>包装模式</code>，以后会介绍到。适配器模式是一种补救模式，他可以让你从因业务扩展而系统无法迅速适应的苦恼中解脱出来。我们在进行系统开发时，不管之前的可行性分析、需求分析、系统设计处理的多么完美，总会在关键时候、关键场合出现一些“意外”。这些“意外”，该来的还是要来，躲是躲不过的，而这时就是我们的<code>适配器模式</code>的用武之地。<code>适配器模式</code>最好在设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题，没有一个系统分析师会再做详细设计时考虑使用<code>适配器模式</code>。</p>

<p><code>适配器模式</code>包含两种，一种是<code>类适配器</code>，另一种是<code>对象适配器</code>。<code>类适配器</code>是通过类的继承实现的适配，而<code>对象适配器</code>是通过对象间的关联关系，组合关系实现的适配。二者在实际项目中都会经常用到，由于<code>对象适配器</code>是通过类间的关联关系进行耦合的，因此在设计时就可以做到比较灵活，而<code>类适配器</code>就只能通过覆写源角色的方法进行拓展，在实际项目中，<code>对象适配器</code>使用到的场景相对较多。在<code>iOS</code>开发中也推荐多使用组合关系，而尽量减少继承关系，这是一种很好的编程习惯，因此我在这里只介绍<code>对象适配器</code>，想了解更多的关于<code>类适配器</code>的话，请自行<code>Google</code>之。</p>

<h4>适配器模式定义</h4>

<p><code>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.(将一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。)</code></p>

<!-- More -->


<h4>适配器模式类图</h4>

<p>{% img <a href="https://oac67o3cg.qnssl.com/1475114532.png">https://oac67o3cg.qnssl.com/1475114532.png</a> %}</p>

<h4>适配器模式说明</h4>

<ul>
<li>Target目标角色
该角色定义把其他类转换为何种接口，也就是我们的期望接口。</li>
<li>Adaptee源角色
你想把“谁”转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。</li>
<li>Adapter适配器角色
适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，他的职责非常简单：把源角色转换为目标角色。</li>
</ul>


<h4>适配器模式优点</h4>

<ol>
<li>适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</li>
<li>增加了类的透明性。我们访问的是目标角色，但是实现却在源角色里。</li>
<li>提高了类的复用度。源角色在原有系统中还是可以正常使用的。</li>
<li>灵活性非常好。不想要适配器时，删掉这个适配器就好了，其他代码不用改。</li>
</ol>


<h4>适配器模式的objective-C实现</h4>

<p>{% codeblock Target lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@protocol Target <NSObject></p>

<ul>
<li>(void)userExpectInterface;</li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock Adaptee lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface Adaptee : NSObject</p>

<ul>
<li>(void)doSometing;</li>
</ul>


<p>@end</p>

<p>@implementation Adaptee</p>

<ul>
<li>(void)doSometing
{
  NSLog(@&ldquo;adaptee doing something!&rdquo;);
}</li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock Adapter lang:objc %}</p>

<h1>import &ldquo;Target.h&rdquo;</h1>

<h1>import &ldquo;Adaptee.h&rdquo;</h1>

<p>@interface Adapter : NSObject<Target></p>

<p>@property (strong, nonatomic) Adaptee *adaptee;</p>

<ul>
<li>(id)initWithAdaptee:(Adaptee *)adaptee;</li>
</ul>


<p>@end</p>

<p>@implementation Adapter</p>

<p>@synthesize adaptee = _adaptee;</p>

<ul>
<li><p>(id)initWithAdaptee:(Adaptee *)adaptee
{
  if (self = [super init]) {
      _adaptee = adaptee;
  }
  return self;
}</p></li>
<li><p>(void)userExpectInterface
{
  [self.adaptee doSometing];
}</p></li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock main lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;Adapter.h&rdquo;</h1>

<h1>import &ldquo;Adaptee.h&rdquo;</h1>

<h1>import &ldquo;Target.h&rdquo;</h1>

<p>int main(int argc, const char * argv[])
{</p>

<pre><code>@autoreleasepool {

    Adaptee *adaptee = [[Adaptee alloc]init];
    id&lt;Target&gt; object = [[Adapter alloc]initWithAdaptee:adaptee];

    [object userExpectInterface];

}
return 0;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23种设计模式——观察者模式]]></title>
    <link href="http://blog.wtlucky.com/blog/2013/03/20/observer/"/>
    <updated>2013-03-20T21:04:00+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2013/03/20/observer</id>
    <content type="html"><![CDATA[<p>这次来介绍一下观察者模式，这种模式可以说使用的是最多的，也最常见。我们现在使用的智能手机的应用在本质上也都是观察者模式的一种体现，这些手机应用都是事件驱动机制，只要有事件发生，就会做出一系列的响应处理，在没有事件的时候，什么也不会发生。这就是观察者模式，观察者模式需要一个被观察者，和一个或者多个观察者。当被观察者的状态发生改变时，观察者会做出相应的处理。</p>

<h4>观察者模式定义</h4>

<p>观察者模式（Observer Pattern）也叫做发布订阅模式（Publish/subscribe）。
<code>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.(定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于他的对象都会得到通知并被自动更新。)</code></p>

<!-- More -->


<h4>观察者模式类图</h4>

<p>{% img <a href="https://oac67o3cg.qnssl.com/1475114496.png">https://oac67o3cg.qnssl.com/1475114496.png</a> %}</p>

<h4>观察者模式说明</h4>

<ul>
<li>Subject被观察者
定义被观察者必须实现的职责，它必须能够动态的增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。</li>
<li>Observer观察者
观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。</li>
<li>ConcreteSubject具体的被观察者
定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。</li>
<li>ConcreteObserver具体的观察者
每个观察者在接收到消息后的处理反应应是不同的，各个观察者有自己的处理逻辑。</li>
</ul>


<h4>观察者模式的优点</h4>

<ol>
<li>观察者和被观察者之间是抽象耦合</li>
<li>建立一套触法机制</li>
</ol>


<h4>观察者模式的缺点</h4>

<p>观察者模式需要考虑开发效率和运行效率的问题。</p>

<h4>观察者模式在iOS中的应用</h4>

<p>观察者模式在iOS中的应用我知道主要有两个，一个是消息中心(<code>NSNotificitonCenter</code>)，他并不是严格意义上的观察者模式，但是很类似，首先将观察者注册到消息中心，被观察者可以向消息中心发送消息通知给观察者，从而产生相应的逻辑。再有一个就是<code>Cocoa</code>的<code>KVO</code>机制，也就是<code>Key Value Observer</code>，他可以检测一个对象的某一个属性，当他发生改变时，观察者自动的去调用相应的方法。</p>

<p>下面附上一个用<code>objective-C</code>写的类似的一个观察者模式的小程序：</p>

<p>{% codeblock Student lang:objc %}
@interface Student : NSObject</p>

<p>@property (copy, nonatomic) NSString <em>name;
@property (copy, nonatomic) NSString </em>Ttel;</p>

<ul>
<li>(id)initWithName:(NSString *)aName;</li>
<li>(void)updatePhone:(NSString *)aTel;</li>
</ul>


<p>@end</p>

<p>@implementation Student</p>

<p>@synthesize name = <em>name;
@synthesize Ttel = </em>Ttel;</p>

<ul>
<li><p>(id)initWithName:(NSString *)aName
{
  if (self = [super init]) {
      _name = aName;
  }
  return self;
}</p></li>
<li><p>(void)updatePhone:(NSString *)aTel
{
  self.Ttel = aTel;
}</p></li>
</ul>


<p>@end
{% endcodeblock %}</p>

<p>{% codeblock Teacher lang:objc %}
@interface Teacher : NSObject</p>

<p>@property (copy, nonatomic) NSString <em>tel;
@property (copy, nonatomic) NSString </em>name;
@property (strong, nonatomic) NSMutableArray *observers;</p>

<ul>
<li>(id)initWtihName:(NSString <em>)aName andTel:(NSString </em>)aTel;</li>
<li>(void)addObserver:(NSObject *)aObserver;</li>
<li>(void)removeObserver:(NSObject *)aObserver;</li>
<li>(void)noticeObservers;</li>
</ul>


<p>@end</p>

<h1>import &ldquo;Student.h&rdquo;</h1>

<p>@implementation Teacher</p>

<p>@synthesize name = <em>name;
@synthesize tel = </em>tel;
@synthesize observers = _observers;</p>

<ul>
<li><p>(id)initWtihName:(NSString <em>)aName andTel:(NSString </em>)aTel
{
  if (self = [super init]) {
      <em>name = aName;
      </em>tel = aTel;
      _observers = [[NSMutableArray alloc]init];
  }
  return self;
}</p></li>
<li><p>(void)addObserver:(NSObject *)aObserver
{
  [_observers addObject:aObserver];
}</p></li>
<li><p>(void)removeObserver:(NSObject *)aObserver
{
  [_observers removeObject:aObserver];
}</p></li>
<li><p>(void)noticeObservers
{
  [self.observers enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
      if ([obj respondsToSelector:@selector(updatePhone:)]) {
          [obj updatePhone:_tel];
      }
  }];
}</p></li>
</ul>


<p>@end</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock main lang:objc %}</p>

<h1>import &ldquo;Student.h&rdquo;</h1>

<h1>import &ldquo;Teacher.h&rdquo;</h1>

<p>int main(int argc, const char * argv[])
{</p>

<pre><code>@autoreleasepool {

    // insert code here...
    Teacher *t = [[Teacher alloc]initWtihName:@"teacher" andTel:@"123456"];
    Student *s1 = [[Student alloc]initWithName:@"Student1"];
    Student *s2 = [[Student alloc]initWithName:@"Student2"];

    [t addObserver:s1];
    [t addObserver:s2];

    NSLog(@"%@ %@", s1.Ttel, s2.Ttel);

    t.tel = @"654321";

    [t noticeObservers];

    NSLog(@"%@ %@", s1.Ttel, s2.Ttel);

}
return 0;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>例子很简单就是老师将电话号码留给同学们，当老师电话号码改变时，同学们自动的也会将老师的电话号码改变。其实写的并不好，最好还是定义两个<code>Protocol</code>，一个是<code>Observer</code>一个是<code>Subject</code>，然后老师和学生分别遵循<code>Observer</code>和<code>Subject</code>协议，这样的话就比较好了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23种设计模式——单例模式]]></title>
    <link href="http://blog.wtlucky.com/blog/2013/03/19/singleton/"/>
    <updated>2013-03-19T19:35:00+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2013/03/19/singleton</id>
    <content type="html"><![CDATA[<p>本学期开了一门课程叫做《软件体系结构》，讲的主要是设计模式的东西，而我在之前也看过设计模式的书，正好借此机会来整理一下自己所学到的知识，因为自己在做<code>iOS</code>开发，所以基本上这23种设计模式我都通过<code>objective-C</code>来实现了。此系列文章的类图都是来自<a href="http://book.douban.com/subject/4260618/">《设计模式之禅》</a>，有兴趣的同学可以去买这本书看。</p>

<p>话说，在编码编到一定的程度以后，由于代码体系的庞大，结构的复杂，自然就会上升到设计模式高度，而现在的软件设计又基本都是面向对象的，所以有了设计模式作支持，可以使软件更加的稳定安全，也更易于维护与拓展。</p>

<p>首先来介绍最常用最简单的单例模式（Singleton），在以后的文章中再依次介绍其他的模式。</p>

<h4>单例模式定义</h4>

<p><code>Ensure a class has only one instance, and provide a global point of access to it. (确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。)</code></p>

<!-- More -->


<h4>单例模式类图</h4>

<p>{% img <a href="https://oac67o3cg.qnssl.com/1475114445.png">https://oac67o3cg.qnssl.com/1475114445.png</a> %}</p>

<h4>单例模式介绍</h4>

<p>单例模式确保在一个应用中只产生一个实例，这是很有必要的，因为在我们做软件设计的时候，有很多对象都是只需要一个就可以了，而不需要创建众多的对象，这样最显而易见的就是节省了内存空间。而且避免了这个类的频繁的初始化与销毁。有时为了实现某一种功能与操作而创建的类（工具类）往往也不需要多个对象，使用单例模式再合适不过。再延伸一点，有时为了节省内存对一个对象进行复用的话也可以通过单例来实现，这在手机软件的开发中用得比较多，因为手机的内存实在是少得可怜。</p>

<h4>单例模式优点</h4>

<ol>
<li>正如前面说的，单例模式在内存中只有一个实例，减少了内存开支。特别是一个对象需要频繁的创建、销毁时，而创建与销毁的性能有无法优化，单例模式的优势就非常明显。</li>
<li>单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用。</li>
<li>单例模式可以在系统设置全局的访问点，优化和共享资源访问。</li>
</ol>


<h4>单例模式缺点</h4>

<ol>
<li>单例模式一般没有接口，扩展很困难，除了修改代码基本上没有第二种途径实现。</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的。</li>
<li>单例模式与单一职责原则有冲突。</li>
</ol>


<h4>单例模式在iOS中的使用</h4>

<p>单例模式在<code>iOS</code>开发中的使用还是蛮多的，许多<code>Foundation</code>、<code>Cocoa</code>和<code>UIKit</code>中的类都实现了单例模式，比如应用程序本身<code>UIApplication</code>、文件操作类<code>NSFileManager</code>、消息中心<code>NSNotificitonCenter</code>等系统都已经给我们实现单例，我们只需要使用就好了。在<code>iOS</code>中使用单例模式要使用类方法，通过类方法返回该类的唯一对象。</p>

<p>我知道的在<code>iOS</code>开发中实现单例模式主要有以下三种方式：</p>

<h5>第一种</h5>

<p>该方法是苹果的官方文档中写的一种方式，通过覆盖<code>NSObject</code>的部分方法实现，使该类无法<code>alloc</code>、<code>retain</code>、<code>release</code>。这是最麻烦的一种方法，也是最不好的一种方法。
{% codeblock Singleton lang:objc %}
static Singleton *instance = nil;</p>

<ul>
<li><p>(Singleton *)sharedInstance
{
  if (instance == nil) {
      instance = [[super allocWithZone:NULL] init];
  }
  return instance;
}</p></li>
<li><p>(id)allocWithZone:(NSZone *)zone
{
  return [[self sharedInstance] retain];
}</p></li>
<li><p>(id)copyWithZone:(NSZone *)zone
{
  return self;
}</p></li>
<li><p>(id)retain
{
  return self;
}</p></li>
<li><p>(NSUInteger)retainCount
{
  return NSUIntegerMax;  //denotes an object that cannot be released
}</p></li>
<li><p>(void)release
{
  //do nothing
}</p></li>
<li><p>(id)autorelease
{
  return self;
}
{% endcodeblock %}</p></li>
</ul>


<p>可以看到这种方式，使用静态成员维持了一个永久存在的对象，而且覆盖了<code>alloc</code>方法（<code>alloc</code>方法会调用<code>allocWithZone:</code>方法），并且也覆盖了所有与引用技术有关的方法，这都使这个对象不会被销毁。这样看上去基本实现了我们需要的，但是写起来麻烦不说，还有很大的一个问题，那就是多线程问题，如果是在多线程中那么该种方法就不能保证只产生一个对象了。所以这种方式只是介绍一下，并不推荐使用。</p>

<h5>第二种</h5>

<p>第二种跟第一种差不多，也是通过覆盖<code>NSObject</code>的方法实现的，但是它在第一种的基础上增加了多线程的处理，所以即使在多线程下，该种方法创建的对象也是唯一的。这种方法已经有大牛为我们写好了，全都都是通过<code>C</code>的宏定义<code>#define</code>出来了。现给出该头文件：
{% include_code designPattern/SynthesizeSingleton.h lang:c %}
使用时也非常方便，该头文件也已给出使用方法，在这里我在说一下，供那些E文不好的同学使用。</p>

<p>使用这种方式首先把该头文件加到我们的项目中，然后直接使用就可以了：
{% codeblock Singleton.h lang:objc %}</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;SynthesizeSingleton.h&rdquo;</h1>

<p>@interface Singleton : NSObject</p>

<p>SYNTHESIZE_SINGLETON_FOR_CLASS_HEADER(Singleton);</p>

<p>//定义该类的属性，方法等</p>

<p>@end
{% endcodeblock %}</p>

<p>{% codeblock Singleton.m lang:objc %}
@implementation Singleton</p>

<p>SYNTHESIZE_SINGLETON_FOR_CLASS(Singleton);</p>

<p>//属性方法的实现</p>

<p>@end
{% endcodeblock %}</p>

<p>如此一来在使用时，通过<code>[Singleton sharedInstance]</code>就可以获得该类的单例对象了。
这种方法由于有了这个头文件的支持，所以使得使用单例方便多了，而且也避免了多线程的问题。</p>

<h5>第三种</h5>

<p>这是最后一种也是我最推荐的一种。<code>iOS</code>在4.0以后推出了<code>block</code>和<code>GCD</code>，这两个特性给<code>iOS</code>开发带来的很大的便利，也使开发变得更加趣味话。那么如何通过<code>GCD</code>+<code>block</code>来实现单例模式呢，这主要归功于<code>dispatch_once(dispatch_once_t *predicate, ^(void)block)</code>这个<code>GCD</code>的函数，他有两个参数第一参数是一个指向<code>dispatch_once_t</code>类型结构体的指针，用来测试<code>block</code>是否执行完成，该指针所指向的结构体必须是全局的或者静态的，第二个参数是一个返回值与参数均为空的<code>block</code>，在<code>block</code>体中进行对象的初始化即可。<code>dispatch_once</code>在程序的生命周期中保证只会被调用一次，所以在多线程中也不会有问题。
该种方法使用方法：
{% codeblock Singleton lang:objc %}
+ (Singleton <em>)sharedInstance
{
    static Singleton </em>instance = nil;</p>

<pre><code>static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    instance = [[Singleton alloc]init];
});

return instance;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>使用该种方法只需要这简单的几句代码就可以实现单例了。使用起来非常方便，但是这种创建单例的方法也不是完美的，它并不能阻止人们通过<code>alloc</code>方法来实例化一个对象，所以这并不是严格意义上的单例模式，但是一般程序都是我们自己写，我们自己记得就好了，这也没什么可担心的，从这一点上来说第二种方法又是比较好的，具体使用的时候呢，根据实际情况来吧，各取所需就好了。</p>
]]></content>
  </entry>
  
</feed>
