<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios development | GeekerProbe]]></title>
  <link href="http://blog.wtlucky.com/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://blog.wtlucky.com/"/>
  <updated>2016-09-29T10:51:03+08:00</updated>
  <id>http://blog.wtlucky.com/</id>
  <author>
    <name><![CDATA[wtlucky ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[__bridge_retain __bridge_transfer]]></title>
    <link href="http://blog.wtlucky.com/blog/2016/06/04/bridge-retain-bridge-transfer/"/>
    <updated>2016-06-04T16:34:46+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2016/06/04/bridge-retain-bridge-transfer</id>
    <content type="html"><![CDATA[<h3>CF对象与NS对象互转</h3>

<p>在ARC下，如果我们需要操作一些底层的库，有时会用到Core Foundation的对象，简称CF对象，例如Core Graphic、Core Text。在ARC下，这些CF的对象的内存是不会被自动管理的，而是需要我们在它的生命周期结束的时候调用CFRelease()释放它。</p>

<p>CF对象与NS对象之间如何相互转换呢？系统提供了<strong>bridge,</strong>bridge_retained,__bridge_transfer 三个关键字给我们使用。</p>

<!-- More -->


<h4>__bridge</h4>

<p>__bridge只是单纯的对象类型的转换，并没有涉及到对象所有权的转移，所以需要把握好对象的生命周期，否则会出项野指针的情况。</p>

<p>{% codeblock lang:objc %}
void <em>p = 0;
do {
    id obj = [[UIActivity alloc] init];
    p = (__bridge void </em>)obj;  // 出了作用域，obj被释放。
} while (0);
{
    id foo = [NSObject new];  // 为了切实将释放的内存被占用。
}
NSLog(@&ldquo;class=%@&rdquo;, [(__bridge id)p class]);  // p为野指针，crash
{% endcodeblock %}</p>

<p><img src="https://oac67o3cg.qnssl.com/1475116928.png" alt="" /></p>

<p>NS对象转为CF对象会出项野指针，逆过来CF转NS对象则有可能会出现内存泄露的问题，具体见下面的<strong>bridge_transfer的介绍。简单来说</strong>bridge就是类型强制转换。</p>

<h4>__bridge_retained</h4>

<p>__bridge_retained用于将NS对象转为CF对象，这其中有所有权的转移，NS对象会被retain一次再交给CF处理，这样即使原始的NS的对象在被ARC自动处理release一次之后，它的retainCount也不会为0，从而不会被销毁。</p>

<p>{% codeblock lang:objc %}
void <em>p = 0;
do {
    id obj = [[UIActivity alloc] init];
    p = (__bridge_retained void </em>)obj;  // 出了作用域，obj被释放。p同时也有了所有权’</p>

<p>} while (0);
{
    id foo = [NSObject new];  // 为了切实将释放的内存被占用。
}
NSLog(@&ldquo;class=%@&rdquo;, [(__bridge id)p class]);  // 正确打印UIActivity
{% endcodeblock %}</p>

<p>看一下引用计数的变化</p>

<p>{% codeblock lang:objc %}
NSString *foo = [[NSString alloc] init];
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount((<strong>bridge CFTypeRef)foo)); // 1152921504606846975
CFTypeRef rfoo = (</strong>bridge_retained CFTypeRef)foo;
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount(rfoo)); // 1152921504606846975
{% endcodeblock %}</p>

<p>可以看到引用计数是一个超级大的整数，这是因为在arc下直接创建的Foundation对象的引用计数都被处理过了，无法看到具体的数值。</p>

<p>这一操作系统给我们提供了一个内联函数来干这件事CFBridgingRetain，</p>

<p>{% codeblock lang:objc %}
NS_INLINE CF_RETURNS_RETAINED CFTypeRef <strong>nullable CFBridgingRetain(id </strong>nullable X) {
    return (__bridge_retained CFTypeRef)X;
}
{% endcodeblock %}</p>

<h4>__bridge_transfer</h4>

<p>__bridge_transfer用于将CF对象转为NS对象，同样的这其中也有所有权的转移，CF对象会在转换为NS对象后进行一次release操作，即把所有权完全移交给NS对象来处理，看一下引用计数的变化：</p>

<p>{% codeblock lang:objc %}
CFStringRef ref = CFStringCreateMutable(kCFAllocatorDefault, 0);
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount(ref)); // 1</p>

<p>NSString <em>string = (__bridge_transfer NSString </em>)ref;
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount(ref));  // 1
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount((__bridge CFTypeRef)string)); // 1
{% endcodeblock %}</p>

<p>这里的对象是由Core Foundation创建的，所以它的引用计数可以被打印出来，可以看到在ARC环境下，string会被声明成strong类型，所以这个对象的retainCount会被加1，但是转换之后仍然为1，即CF对象已经放弃了它的所有权。</p>

<p>如果是__bridge的话</p>

<p>{% codeblock lang:objc %}
CFStringRef ref = CFStringCreateMutable(kCFAllocatorDefault, 0);
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount(ref)); // 1</p>

<p>NSString <em>string = (__bridge NSString </em>)ref;
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount(ref));  // 2
NSLog(@&ldquo;%lu&rdquo;, CFGetRetainCount((__bridge CFTypeRef)string)); // 2
{% endcodeblock %}</p>

<p>转换之后的引用计数是2，即CF和NS对象同时有着持有权，这样在出了当前的作用域后，ARC会自动给NS对象做release，但是CF对象需要手动调用CFRelease()，如果忘记了的话，那就是内存泄露。</p>

<p>同样，这一操作系统给也我们提供了一个内联函数来干这件事CFBridgingRetain，
{% codeblock lang:objc %}
NS_INLINE id <strong>nullable CFBridgingRelease(CFTypeRef CF_CONSUMED </strong>nullable X) {
    return (__bridge_transfer id)X;
}
{% endcodeblock %}</p>

<h3>总结</h3>

<p>这其中的关系可以用下图来直接说明，记住这张图就可以了：</p>

<p><img src="https://oac67o3cg.qnssl.com/1475116891.png" alt="" /></p>

<p>————————————</p>

<p><img src="https://oac67o3cg.qnssl.com/1475114982.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Support for IPv6]]></title>
    <link href="http://blog.wtlucky.com/blog/2016/05/09/support-for-ipv6/"/>
    <updated>2016-05-09T15:41:22+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2016/05/09/support-for-ipv6</id>
    <content type="html"><![CDATA[<p>苹果于2016年5月4日告知开发者应用需要在6月1日前支持IPv6-only,也就是说在 6 月 1 日后发布的新版本是需要支持 IPv6-only。</p>

<p>原文地址：<a href="https://developer.apple.com/news/?id=05042016a">https://developer.apple.com/news/?id=05042016a</a></p>

<p>首先看下图</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/art/NetworkingFrameworksAndAPIs_2x.png" alt="image" /></p>

<p>其中蓝色部分的高级API，其实都已经帮我们做好了IPv6的支持，我们使用的大多数第三方网络库也都是基于这些高级API的，所以这里我们不需要做什么改动。
需要注意的是下面的红色部分的底层的socket API需要做出适配支持。</p>

<!-- More -->


<h2>适配支持方案</h2>

<ul>
<li>不要使用硬编码的IPv4的地址，取而代之应该使用域名;</li>
<li>搜一下是否有用到下面的这些API，这些API都是只针对IPv4做处理的，删除掉就可以：

<blockquote><ul>
<li>inet_addr()</li>
<li>inet_aton()</li>
<li>inet_lnaof()</li>
<li>inet_makeaddr()</li>
<li>inet_netof()</li>
<li>inet_network()</li>
<li>inet_ntoa()</li>
<li>inet_ntoa_r()</li>
<li>bindresvport()</li>
<li>getipv4sourcefilter()</li>
<li>setipv4sourcefilter()</li>
</ul>
</blockquote></li>
<li>如果项目中用到了以下的IPv4的类型，那么也要支持相应的IPv6类型</li>
</ul>


<p><img src="https://oac67o3cg.qnssl.com/1475116800.png" alt="" /></p>

<ul>
<li>如果强制需要使用IPv4的地址，苹果官方的适配方法给出了解决方式。<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html">Use System APIs to Synthesize IPv6 Addresses</a></li>
</ul>


<h2>适配支持验证方法</h2>

<p>测试验证方式就是通过Mac的共享网络共享一个IPv6的无线网，跟已往创建方式不同的是进入共享时需要按住<code>Option</code>键，不然<code>Create NAT64 Network</code>的选项不会出现</p>

<p><img src="https://oac67o3cg.qnssl.com/1475116819.png" alt="" /></p>

<p>然后开启无线共享，使iPhone连接上分享出来的热点即可
注：需要将iPhone的蜂窝网络数据关掉，以保证只有通过WiFi在连接网络。</p>

<h2>适配经验</h2>

<p>在自己的项目中检查了一下，需要做出修改的都是集中在网路库的<code>Reachability</code>相关操作中。如<code>AFNetworking</code>的<code>AFNetworkReachabilityManager</code>，它已经支持了IPv6，但是在他的支持中加了个一个条件编译的选项，判断了系统的版本，一直不明白它这么做的原因是什么，因此我也提交了一个<a href="https://github.com/AFNetworking/AFNetworking/issues/3498">issue</a>询问了下，等待大神给出解释。</p>

<blockquote><p><strong>UPDATE：2016年05月11日：</strong></p>

<p>后来发现<code>Reachability</code>在iOS9以下的系统上如果适配了IPv6的话则会导致失效，网络监测状态不准，应该是苹果自身的bug，所以在这些系统上还需要使用IPv4的数据结构，<code>AFNetworking</code>的大神也对我的<a href="https://github.com/AFNetworking/AFNetworking/issues/3498">issue</a>给出了解答，同时在<code>Alamofire</code>中也有对这个bug描述的<a href="https://github.com/Alamofire/Alamofire/issues/1228">issue</a>。</p></blockquote>

<p>除此之外，我们自己也用到了一个<code>Reachability</code>的类似物，这就需要对它单独做出IPv6的支持，具体方法可以参照<code>Apple</code>自己官方提供的<a href="https://developer.apple.com/library/ios/samplecode/Reachability/Listings/Reachability_Reachability_h.html"><code>Reachability</code>Demo</a>，这个Demo中的ReadMe中也介绍了一些很有用的信息。</p>

<blockquote><h5>IPv6 Support</h5>

<p>Reachability fully supports IPv6.  More specifically, each of the APIs handles IPv6 in the following way:</p>

<ul>
<li><p>reachabilityWithHostName and SCNetworkReachabilityCreateWithName:  Internally, this API works be resolving the host name to a set of IP addresses (this can be any combination of IPv4 and IPv6 addresses) and establishing separate monitors on all available addresses.</p></li>
<li><p>reachabilityWithAddress and SCNetworkReachabilityCreateWithAddress:  To monitor an IPv6 address, simply pass in an IPv6 <code>sockaddr_in6 struct</code> instead of the IPv4 <code>sockaddr_in struct</code>.</p></li>
<li><p>reachabilityForInternetConnection:  This monitors the address 0.0.0.0, which reachability treats as a special token that causes it to actually monitor the general routing status of the device, both IPv4 and IPv6.</p></li>
</ul>


<h5>Removal of reachabilityForLocalWiFi</h5>

<p>Older versions of this sample included the method reachabilityForLocalWiFi. As originally designed, this method allowed apps using Bonjour to check the status of &ldquo;local only&rdquo; Wi-Fi (Wi-Fi without a connection to the larger internet) to determine whether or not they should advertise or browse.</p>

<p>However, the additional peer-to-peer APIs that have since been added to iOS and OS X have rendered it largely obsolete.  Because of the narrow use case for this API and the large potential for misuse, reachabilityForLocalWiFi has been removed from Reachability.</p>

<p>Apps that have a specific requirement can use reachabilityWithAddress to monitor IN_LINKLOCALNETNUM (that is, 169.254.0.0).</p>

<p>Note: ONLY apps that have a specific requirement should be monitoring IN_LINKLOCALNETNUM.  For the overwhelming majority of apps, monitoring this address is unnecessary and potentially harmful.</p></blockquote>

<p>————————————</p>

<p><img src="https://oac67o3cg.qnssl.com/1475114982.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[慎用SafeKit类似物]]></title>
    <link href="http://blog.wtlucky.com/blog/2016/04/24/be-careful-with-safekit/"/>
    <updated>2016-04-24T21:06:13+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2016/04/24/be-careful-with-safekit</id>
    <content type="html"><![CDATA[<p>SafeKit一般指那些被用来防止App crash的类库或者方案，常见的方式有通过<code>method swizzling</code>替换系统方法，或者通过消息转发机制将无法响应的方法都转发给一个可以handle任何消息的对象身上等。通过这些方式都可以将·常见数组越界、<code>unrecognized selector sent to instante 0xXXXXXXXX</code>等crash类型在App内部自身得到消化处理，从而将程序的crash率降到一个可以接受的范围内。</p>

<p>在我刚刚开始写Objective-C代码的时候，觉得这是一种非常好的编程方式，应该大力推崇，能够极大地降低crash率，想怎么写代码就怎么写代码，妈妈再也不担心我的程序会crash了。<strong>但是</strong>，后来渐渐发现这并不是一种很好的解决方案，它其实是一把双刃剑。在给我们带来便利的同时也给我们带来了一些不利的地方。这就是本次讨论的主题<code>慎用或者不用SafeKit类似物</code>。</p>

<!-- More -->


<p>SateKit的实现一般都是借助于Objective-C的runtime特性，但是这样实现起来就会很黑，也就是我们常说的<strong>黑魔法</strong>，<strong>黑魔法</strong>往往能给我们带来意想不到的效果，但是这样一来就将一些本该在程序的编译期就该发现的问题给滞后到了程序的运行时，甚至将本该暴露的问题而隐藏了起来。这种方式其实被我们称为<code>埋车头</code>的方案，发生了错误，没有响应机制，而是将事故车头埋藏起来，对外表现出一切良好。如此看来这种方式是我们万万不可取的，长期下去，只会产出越来越多的不稳定代码，代码中的问题不能及时暴露出来，久而久之成为编码习惯，后果可想而知。</p>

<p>最近工作中还遇到了一件与使用SafeKit相关的事儿，着实是踩了个坑，拿出来分享下。具体情况是这样，有一个宿主程序，他接收各个业务方以SDK的方式提供给它的静态库以供其正常运行。而我负责开发其中的一个SDK，在开发完成之后也通过了宿主程序接入验证，并由QA验证交付给宿主方后。却得到了宿主方QA的反馈说我们页面展示有问题，无数据展示。这怎么可能呢，在我们自己这里好好的，也自己接入宿主程序验证过，没有任何问题。要来宿主方的测试ipa，安装后发现确实有问题，通过抓包发现有数据请求也有正确数据返回，但是就是页面数据无法展示，真是见了鬼。只好同他们的RD要来最新的宿主程序，测试发现在新的宿主程序上确实有问题，但是老的宿主程序就没有问题，同样的是一份代码，问题肯定就出现在宿主程序上。</p>

<p>虽然明确知道问题出在宿主程序上，但是人家是大爷，你是不能让人家去查找修复问题的，只能用宿主程序和自己的SDK代码去Debug了，最后发现在数据解析时，见鬼了。
{% codeblock lang:objc %}
NSArray <em>path = @[@“this”, @“is”, @“path”, @“string”];
path = [path valueForKeyPath:NSStringFromSelector(@selector(capitalizedString))];
NSLog(@“%@”, path); // [<NSNull null>, <NSNull null>, <NSNull null>, <NSNull null>]
{% endcodeblock %}
我取首字母转大写的string，最后怎么给我一堆<code>NSNull</code>对象，也正是因为导致我数据解析失败。<code>KVC</code>返回<code>NSNull</code>，难道是我用错了？那我就不用<code>one line of code</code>，使用另外的方式试试：
{% codeblock lang:objc %}
NSArray </em>path = @[@“this”, @“is”, @“path”, @“string”];
NSMutableArray <em>paths = [NSMutableArray arrayWithCapacity:path.count];
[path enumerateObjectsUsingBlock:^(NSString </em> <em>Nonnull obj, NSUInteger idx, BOOL * </em>Nonnull stop) {
    NSString *str = [obj capitalizedString];
    [paths addObject:str];
}];
NSLog(@“%@”, paths); // [@“This”, @“Is”, @“Path”, @“String”]
{% endcodeblock %}</p>

<p>这样是正确ok的，那说明我的<code>KVC</code>没有用错啊，难道是宿主方把<code>KVC</code>禁用掉了，或者是给黑掉了？联系对方RD检查宿主工程，说没有禁用<code>valueForKeyPath:</code>，没有找到相关代码，他们自身也在用（自身也在用都没有发现问题么？我觉得随便在宿主工程里建个VC，写个KVC都是会返回NSNull的）。还是那句话人家是大爷，只能自己SDK方修改，去掉这里的<code>KVC</code>。其实我们的SDK中大量使用了<code>valueForKeyPath: </code>，只修改这一处肯定是不行的，其他地方同样会出问题，果然第二天，他们又发现的其他的问题，经确认还是<code>KVC</code>返回<code>NSNull</code>的问题。</p>

<p>总不能把所有的<code>KVC</code>都给改掉？最后强烈要求对方去排查，自己也通过增加符号断点<code>-[NSObject valueForKeyPath:]</code>追查，并未发现任何异常，看来只能是在runtime里干事儿了。最终宿主方通过逐个排除SDK的方式，发现问题就出在另一个业务方的SDK上。</p>

<p>我猜他们一定是使用了SafeKit类似的东西，将<code>valueForKeyPath: </code>进行了处理，写一段伪码大概就是：
{% codeblock lang:objc %}
- (id)fd_valueForKeyPath:(NSString *)keyPath {
    if (![keyPath isSafe]) { // 一些安全性检查
        return [NSNull null];
    }
    return [self fd_valueForKeyPath:keyPath];
}
{% endcodeblock %}
所以要么是<code>method swizzling</code>替换了实现，要么是通过<code>category</code>重写覆盖了原始的系统方法。</p>

<p>所以回到主题上来，SafeKit这种东西还是慎用或者别用的好，一方面把本应该暴露出的问题给隐藏了起来，这会导致开发者过于依赖SafeKit，没有了它，代码的质量将急剧下降。另一方面，如果你的代码还会融入到其他的工程中去的话，例如产品自身是一个SDK，那么使用SafeKit或者runtime Hook了系统方法，那么带来的将是毁灭性的灾难。因为这对使用你SDK的宿主方的开发带来极大的不变。因为这是侵染性的处理方式，不仅仅是在你自己的SDK中SafeKit会起作用，同样的在整个宿主App内都会起作用。如此一来不出问题还好，一旦出了问题，那排查起来简直让人崩溃。</p>

<p>————————————</p>

<p><img src="https://oac67o3cg.qnssl.com/1475114982.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FDStackView —— Downward Compatible UIStackView (Part 3)]]></title>
    <link href="http://blog.wtlucky.com/blog/2016/02/04/fdstackview-downward-compatible-uistackview-part-3/"/>
    <updated>2016-02-04T15:24:55+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2016/02/04/fdstackview-downward-compatible-uistackview-part-3</id>
    <content type="html"><![CDATA[<p>上一篇<a href="http://blog.wtlucky.com/blog/2016/01/19/fdstackview-downward-compatible-uistackview-part-2/"><code>Part 2</code></a>只介绍了第一个技术点<strong><code>alignment</code>和<code>distribution</code>的约束如何添加和管理</strong>的<code>alignment</code>这一部分的内容，这一篇继续介绍<code>distribution</code>的约束添加和管理。</p>

<p>同样的在介绍实现之前，我先介绍一下<code>StackView</code>的各种<code>distribution</code>模式都是什么效果的：</p>

<!-- More -->


<ul>
<li><strong>UIStackViewDistributionFill</strong>：这种应该是目前最常用的了，它就是将<code>arrangedSubviews</code>填充满整个<code>StackView</code>，如果设置了spacing，那么这些<code>arrangedSubviews</code>之间的间距就是spacing。如果减去所有的spacing，所有的<code>arrangedSubview</code>的固有尺寸(<code>intrinsicContentSize</code>)不能填满或者超出<code>StackView</code>的尺寸，那就会按照<code>Hugging</code>或者<code>CompressionResistance</code>的优先级来拉伸或压缩一些<code>arrangedSubview</code>。如果出现优先级相同的情况，就按排列顺序来拉伸或压缩。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/distribute_fillroportionally_2x_4a83cd74-be8d-4ef1-adf9-c5252a1bcc65.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewDistributionFillEqually</strong>：这种就是<code>StackView</code>的尺寸减去所有的spacing之后均分给<code>arrangedSubviews</code>，每个<code>arrangedSubview</code>的尺寸是相同的。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/distribute_fillequally_2x_5ccda608-869a-48b9-9515-9b6314d091a9.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewDistributionFillProportionally</strong>：这种跟FillEqually差不多，只不过这个不是讲尺寸均分给<code>arrangedSubviews</code>，而是根据<code>arrangedSubviews</code>的<code>intrinsicContentSize</code>按比例分配。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/distribute_fillroportionally_2x_4a83cd74-be8d-4ef1-adf9-c5252a1bcc65.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewDistributionEqualSpacing</strong>：这种是使<code>arrangedSubview</code>之间的spacing相等，但是这个spacing是有可能大于<code>StackView</code>所设置的spacing，但是绝对不会小于。这个类型的布局可以这样理解，先按所有的<code>arrangedSubview</code>的<code>intrinsicContentSize</code>布局，然后余下的空间均分为spacing，如果大约<code>StackView</code>设置的spacing那这样就OK了，如果小于就按照<code>StackView</code>设置的spacing，然后按照<code>CompressionResistance</code>的优先级来压缩一个<code>arrangedSubview</code>。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/distribute_equalspacing_2x_6668568b-a445-402c-94ae-f5e85b0b10bd.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewDistributionEqualCentering</strong>：这种是使<code>arrangedSubview</code>的中心点之间的距离相等，这样没两个<code>arrangedSubview</code>之间的spacing就有可能不是相等的，但是这个spacing仍然是大于等于<code>StackView</code>设置的spacing的，不会是小于。这个类型布局仍然是如果<code>StackView</code>有多余的空间会均分给<code>arrangedSubviews</code>之间的spacing，如果空间不够那就按照<code>CompressionResistance</code>的优先级压缩<code>arrangedSubview</code>。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/distribute_equalcentering_2x_7089d0d3-f161-452b-ab3e-9885c7b6101e.png" alt="image" /></p>

<p>在介绍<code>distribution</code>的约束创建和管理的过程中也涉及到了第二个知识点<strong><code>spacing</code>和<code>distribution</code>的关系及约束的创建</strong>的内容，所以这两部都在这里介绍了。</p>

<p><code>distribution</code>方向同样也包括4种约束，这4种约束也都是添加到<code>canvas</code>上的，除此之外它还包括一组通过<code>NSMapTable</code>维护的<code>FDGapLayoutGuide</code>。</p>

<p>{% codeblock lang:objc %}
@interface FDStackViewDistributionLayoutArrangement : FDStackViewLayoutArrangement
@property (nonatomic, strong) NSMutableArray<NSLayoutConstraint *> <em>canvasConnectionConstraints;
@property (nonatomic, strong) NSMapTable<UIView *, NSLayoutConstraint *> </em>edgeToEdgeConstraints;
@property (nonatomic, strong) NSMapTable<UIView *, NSLayoutConstraint *> <em>relatedDimensionConstraints;
@property (nonatomic, strong) NSMapTable<UIView *, NSLayoutConstraint *> </em>hiddingDimensionConstraints;</p>

<p>@property (nonatomic, strong) NSMapTable<UIView *, FDGapLayoutGuide *> *spacingOrCenteringGuides;
@end
{% endcodeblock %}</p>

<ul>
<li><strong>canvasConnectionConstraints</strong>：它管路的是<code>arrangedSubviews</code>与<code>canvas</code>之间的约束；</li>
<li><strong>edgeToEdgeConstraints</strong>：它管理的是<code>arrangedSubviews</code>之间一个接一个的约束，这里需要注意这些约束的常量是<code>StackView</code>的spacing，但是关系却不一定是相等。还有就是如果有个<code>arrangedSubview</code>被<code>hidden</code>了那么它仍然参与到<code>edgeToEdge</code>的约束创建及布局中，只不过是把它与后一个<code>arrangedSubview</code>之间的<code>edgeToEdgeConstraint</code>的常量由spacing设置为<code>0</code>。</li>
<li><strong>relatedDimensionConstraints</strong>：它管理的是<code>arrangedSubviews</code>之间<code>distribution</code>各种相等关系的约束，这里面的管理的约束是<code>StackView</code>的<code>distribution</code>布局的精髓所在。如果是<code>UIStackViewDistributionFill</code>模式的话，是没有<code>relatedDimensionConstraint</code>的。<code>UIStackViewDistributionFillEqually</code>与<code>UIStackViewDistributionFillProportionally</code>使用的是一种类型的约束，而<code>UIStackViewDistributionEqualCentering</code>与<code>UIStackViewDistributionEqualSpacing</code>使用的却是另一种类型的约束，后面在详细介绍。</li>
<li><strong>hiddingDimensionConstraints</strong>：它管理的是当<code>arrangedSubviews</code>有<code>hidden</code>的时候，该<code>arrangedSubview</code>的有关<code>dimensionAttribute</code>的约束；</li>
<li><strong>spacingOrCenteringGuides</strong>：这个管理的就不是约束了，它是一组<code>FDGapLayoutGuide</code>，只用在<code>UIStackViewDistributionEqualCentering</code>和<code>UIStackViewDistributionEqualSpacing</code>这两种模式中，<code>FDGapLayoutGuide</code>用来连接左右两个<code>arrangedSubView</code>，作为一个辅助view来约束左右两个view的位置关系。<code>spacingOrCenteringGuides</code>的key是<code>FDGapLayoutGuide</code>连接的左边的<code>arrangedSubview</code>。</li>
</ul>


<p>最后说明的就是<code>FDGapLayoutGuide</code>与<code>arrangedSubView</code>相连接的约束没有被<code>NSMapTable</code>所管理，它们就只是被加到了<code>canvas</code>上。因为当模式改变时，所有的<code>FDGapLayoutGuide</code>会被移除或者重建，所以跟它们相关的约束也会被一并清楚。</p>

<p>那么以上几种约束的创建顺序是怎样的呢？</p>

<ol>
<li>首先是<code>canvasConnectionConstraints</code>；</li>
<li>其次是每一种模式都会涉及到的<code>edgeToEdgeConstraints</code>；</li>
<li>然后再遍历所有<code>arrangedSubviews</code>，如果有<code>arrangedSubview</code>被<code>hidden</code>了，那么就会创建<code>hiddingDimensionConstraints</code>；</li>
<li>最后是<code>relatedDimensionConstraints</code>，这里如果是<code>UIStackViewDistributionEqualCentering</code>和<code>UIStackViewDistributionEqualSpacing</code>这两种模式的话，会先创建出<code>spacingOrCenteringGuides</code>。</li>
</ol>


<p>下面具体来看，首先<code>canvasConnectionConstraints</code>：
{% codeblock lang:objc %}
- (void)resetCanvasConnectionsEffect {
    [self.canvas removeConstraints:self.canvasConnectionConstraints];
    if (!self.items.count) return;</p>

<pre><code>NSMutableArray *canvasConnectionConstraints = [NSMutableArray new];
NSLayoutAttribute minAttribute = [self minAttributeForCanvasConnections];
NSLayoutConstraint *head = [NSLayoutConstraint constraintWithItem:self.canvas attribute:minAttribute relatedBy:NSLayoutRelationEqual toItem:self.items.firstObject attribute:minAttribute multiplier:1 constant:0];
[canvasConnectionConstraints addObject:head];
head.identifier = @"FDSV-canvas-connection";

NSLayoutConstraint *end = [NSLayoutConstraint constraintWithItem:self.canvas attribute:minAttribute + 1 relatedBy:NSLayoutRelationEqual toItem:self.items.lastObject attribute:minAttribute + 1 multiplier:1 constant:0];
[canvasConnectionConstraints addObject:end];
end.identifier = @"FDSV-canvas-connection";

self.canvasConnectionConstraints = canvasConnectionConstraints;
[self.canvas addConstraints:canvasConnectionConstraints];
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>比较简单，先判断一下不需要创建的情况，然后就是根据<code>axis</code>选用不同的<code>NSLayoutAttribute</code>，将第一个和最后一个<code>arrangedSubview</code>分别与<code>StackView</code>创建相等的约束。这样一来再加上<code>FDStackViewAlignmentLayoutArrangement</code>中创建的两个<code>canvasConnectionConstraints</code>，整个<code>canvas</code>的上下左右四个方向的约束就都有了，满足了<code>canvas</code>布局的基本条件。</p>

<p>接下来是<code>edgeToEdgeConstraints</code>：
{% codeblock lang:objc %}
- (void)resetFillEffect {
    // spacing - edge to edge
    [self.canvas removeConstraints:self.edgeToEdgeConstraints.fd_allObjects];
    [self.edgeToEdgeConstraints removeAllObjects];
    [self.canvas removeConstraints:self.hiddingDimensionConstraints.fd_allObjects];
    [self.hiddingDimensionConstraints removeAllObjects];</p>

<pre><code>UIView *offset = self.items.car;
UIView *last = self.items.lastObject;
for (UIView *view in self.items.cdr) {
    NSLayoutAttribute attribute = [self minAttributeForGapConstraint];
    NSLayoutRelation relation = [self edgeToEdgeRelation];
    NSLayoutConstraint *spacing = [NSLayoutConstraint constraintWithItem:view attribute:attribute relatedBy:relation toItem:offset attribute:attribute + 1 multiplier:1 constant:self.spacing];
    spacing.identifier = @"FDSV-spacing";
    [self.canvas addConstraint:spacing];
    [self.edgeToEdgeConstraints setObject:spacing forKey:offset];
    if (offset.hidden || (view == last &amp;&amp; view.hidden)) {
        spacing.constant = 0;
    }
    offset = view;
}
// hidding dimensions
for (UIView *view in self.items) {
    if (view.hidden) {
        NSLayoutAttribute dimensionAttribute = [self dimensionAttributeForCurrentAxis];
        NSLayoutConstraint *dimensionConstraint = [NSLayoutConstraint constraintWithItem:view attribute:dimensionAttribute relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:0];
        dimensionConstraint.identifier = @"FDSV-hiding";
        [self.canvas addConstraint:dimensionConstraint];
        [self.hiddingDimensionConstraints setObject:dimensionConstraint forKey:view];
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>先移去旧的相关约束，然后将<code>arrangedSubviews</code>依次迭代遍历，根据<code>axis</code>选择正确的<code>NSLayoutAttribute</code>创建首尾相接的约束，常量为<code>StackView</code>的spacing，关系则根据<code>distribution</code>的不同而或等于或大于等于。</p>

<p>这里如前面介绍的一样，如果这个<code>arrangedSubview</code>是<code>hidden</code>的那么它仍然参与<code>edgeToEdgeConstraints</code>的创建，只不过它与后一个<code>arrangedSubview</code>的约束常量不再是spacing而是<code>0</code>。还有一个特殊的就是如果是最后一个<code>arrangedSubview</code>被<code>hidden</code>了，那么它与前一个<code>arrangedSubview</code>的约束的常量也同样是<code>0</code>。</p>

<p>最后再遍历所有<code>arrangedSubviews</code>，如果有<code>arrangedSubview</code>被<code>hidden</code>了，那就根据<code>axis</code>给这个<code>arrangedSubview</code>创建一个常量为<code>0</code>的<code>dimensionConstraint</code>。</p>

<p>如果是<code>UIStackViewDistributionFill</code>的话，那么到这里所有<code>distribution</code>的约束就已经创建完了，已经满足需求了。但是其他几种还要有后续的步骤。</p>

<hr />

<p>先来看<code>UIStackViewDistributionFillEqually</code>和<code>UIStackViewDistributionFillProportionally</code>这两种类型：
{% codeblock lang:objc %}
- (void)resetEquallyEffect {
    [self.canvas removeConstraints:self.relatedDimensionConstraints.fd_allObjects];
    [self.relatedDimensionConstraints removeAllObjects];</p>

<pre><code>NSArray&lt;UIView *&gt; *visiableViews = self.visiableItems;
UIView *offset = visiableViews.car;
CGFloat order = 0;
for (UIView *view in visiableViews.cdr) {
    NSLayoutAttribute attribute = [self dimensionAttributeForCurrentAxis];
    NSLayoutRelation relation = NSLayoutRelationEqual;
    CGFloat multiplier = self.distribution == UIStackViewDistributionFillEqually ? 1 : ({
        CGSize size1 = offset.intrinsicContentSize;
        CGSize size2 = view.intrinsicContentSize;
        CGFloat multiplier = 1;
        if (attribute == NSLayoutAttributeWidth) {
            multiplier = size1.width / size2.width;
        } else {
            multiplier = size1.height / size2.height;
        }
        multiplier;
    });
    NSLayoutConstraint *equally = [NSLayoutConstraint constraintWithItem:offset attribute:attribute relatedBy:relation toItem:view attribute:attribute multiplier:multiplier constant:0];
    equally.priority = UILayoutPriorityRequired - (++order);
    equally.identifier = self.distribution == UIStackViewDistributionFillEqually ? @"FDSV-fill-equally" : @"FDSV-fill-proportionally";
    [self.canvas addConstraint:equally];
    [self.relatedDimensionConstraints setObject:equally forKey:offset];

    offset = view;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>仍然是先干掉旧的约束，然后跟前面不同的是要取出所有的<strong>非hidden</strong>的<code>arrangedSubview</code>添加约束，而不是所有<code>arrangedSubview</code>。</p>

<p>这两个<code>distribution</code>类型是将当前<code>axis</code>所对应的<code>dimensionAttribute</code>的约束作用在<code>arrangedSubviews</code>上，如果是<code>UIStackViewDistributionFillEqually</code>，那么约束的比例(<code>multiplier</code>)就是<code>1</code>，如果是<code>UIStackViewDistributionFillProportionally</code>，那<code>multiplier</code>就需要通过计算得出，是通过两个<code>arrangedSubview</code>的<code>intrinsicContentSize</code>做比值，这样就能保证<code>arrangedSubview</code>最终会按照<code>intrinsicContentSize</code>的比例来分配<code>StackView</code>的空间布局。</p>

<p>再来看<code>UIStackViewDistributionEqualCentering</code>和<code>UIStackViewDistributionEqualSpacing</code>这两种类型：
{% codeblock lang:objc %}
- (void)resetSpacingOrCenteringGuides {
    [self.spacingOrCenteringGuides.fd_allObjects makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.spacingOrCenteringGuides removeAllObjects];
    NSArray<UIView *> *visiableItems = self.visiableItems;
    if (visiableItems.count &lt;= 1) {
        return;
    }</p>

<pre><code>[[visiableItems subarrayWithRange:(NSRange){0, visiableItems.count - 1}] enumerateObjectsUsingBlock:^(UIView *item, NSUInteger idx, BOOL *stop) {
    FDGapLayoutGuide *guide = [FDGapLayoutGuide new];
    [self.canvas addSubview:guide];
    guide.translatesAutoresizingMaskIntoConstraints = NO;
    UIView *relatedToItem = visiableItems[idx+1];

    NSLayoutAttribute minGapAttribute = [self minAttributeForGapConstraint];
    NSLayoutAttribute minContentAttribute;
    NSLayoutAttribute maxContentAttribute;
    if (self.distribution == UIStackViewDistributionEqualCentering) {
        minContentAttribute = self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeCenterX : NSLayoutAttributeCenterY;
        maxContentAttribute = minContentAttribute;
    } else {
        minContentAttribute = minGapAttribute;
        maxContentAttribute = minGapAttribute + 1;
    }

    NSLayoutConstraint *beginGap = [NSLayoutConstraint constraintWithItem:guide attribute:minGapAttribute relatedBy:NSLayoutRelationEqual toItem:item attribute:maxContentAttribute multiplier:1 constant:0];
    beginGap.identifier = @"FDSV-distributing-edge";
    NSLayoutConstraint *endGap = [NSLayoutConstraint constraintWithItem:relatedToItem attribute:minContentAttribute relatedBy:NSLayoutRelationEqual toItem:guide attribute:minGapAttribute + 1 multiplier:1 constant:0];
    endGap.identifier = @"FDSV-distributing-edge";
    [self.canvas addConstraint:beginGap];
    [self.canvas addConstraint:endGap];

    [self.spacingOrCenteringGuides setObject:guide forKey:item];
}];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)resetSpacingOrCenteringGuideRelatedDimensionConstraints {
  [self.canvas removeConstraints:self.relatedDimensionConstraints.fd_allObjects];
  NSArray<UIView *> *visiableItems = self.visiableItems;
  if (visiableItems.count &lt;= 1) return;</p>

<p>  FDGapLayoutGuide <em>firstGapGuide = [self.spacingOrCenteringGuides objectForKey:visiableItems.car];
  [self.spacingOrCenteringGuides.fd_allObjects enumerateObjectsUsingBlock:^(UIView </em>obj, NSUInteger idx, BOOL <em>stop) {
      if (firstGapGuide == obj) return;
      NSLayoutAttribute dimensionAttribute = [self dimensionAttributeForCurrentAxis];
      NSLayoutConstraint </em>related = [NSLayoutConstraint constraintWithItem:firstGapGuide attribute:dimensionAttribute relatedBy:NSLayoutRelationEqual toItem:obj attribute:dimensionAttribute multiplier:1 constant:0];
      related.identifier = @&ldquo;FDSV-fill-equally&rdquo;;
      [self.relatedDimensionConstraints setObject:related forKey:obj];
      [self.canvas addConstraint:related];
  }];
}
{% endcodeblock %}</p></li>
</ul>


<p>先创建<code>spacingOrCenteringGuides</code>，开始是干掉旧的<code>spacingOrCenteringGuides</code>。这里使用的仍然是<strong>visiableItems</strong>。
<code>FDGapLayoutGuide</code>用来连接左右相连的两个可见<code>arrangedSubview</code>。</p>

<p>这两个<code>distribution</code>不同的地方就是<code>UIStackViewDistributionEqualSpacing</code>的<code>FDGapLayoutGuide</code>连接的是<code>arrangedSubview</code>的<code>minAttribute</code>和<code>maxAttribute</code>，而<code>UIStackViewDistributionEqualCentering</code>的<code>FDGapLayoutGuide</code>连接的却是<code>arrangedSubview</code>的<code>centerAttribute</code>。</p>

<p>接下来就是创建<code>relatedDimensionConstraints</code>，就是根据<code>axis</code>不同给对应的<code>dimensionAttribute</code>创建相等的约束即可，这些约束是作用在<code>FDGapLayoutGuide</code>上的，而与前面那两种<code>distribution</code>类型不同。这就是一开始说的<code>relatedDimensionConstraints</code>中的两种类型的约束。</p>

<p>到此整个<code>distribution</code>方向的约束也都创建完了。加上<code>alignment</code>方向创建的约束，<code>StackView</code>已经可以使用了。</p>

<hr />

<p>介绍完这些再回过头来看<a href="http://blog.wtlucky.com/blog/2015/10/09/fdstackview-downward-compatible-uistackview-part-1/">本文章<code>Part 1</code></a>中后面提到的<code>UIStackView</code>的第一个bug，当存在spacing的时候<code>UIStackViewDistributionFillProportionally</code>这个类型的<code>StackView</code>是烂掉的。我刚才看了一下，苹果仍然没有修复这个bug。</p>

<p>具体的原因那篇文章中已经解释了，现在说下为什么<code>FDStackView</code>没有这个问题，相信看完前面创建约束的过程，读者朋友应该就能发现我们并没有像<code>UIStackView</code>那样将<code>canvas</code>的<code>dimensionAttribute</code>乘以一个系数作为<code>arrangedSubview</code>的<code>dimensionConstraint</code>。我们的<code>arrangedSubview</code>的<code>dimensionConstraint</code>是与<code>canvas</code>无关的，是<code>arrangedSubviews</code>之间的比例关系，而且spacing在之前的<code>edgeToEdgeConstraints</code>中就已经创建了，这两者是分开创建的，所以算法不同，自然也就不会出现这个bug。</p>

<hr />

<p>下面看其余的知识点：</p>

<h3>子视图的隐藏显示如何处理</h3>

<p>如果一个已经布好局的<code>StackView</code>，在一个<code>arrangedSubview</code>被<code>hidden</code>或者<code>show</code>之后，那么其余的<code>arrangedSubviews</code>也要做出相应变化，来相应这种变化。</p>

<p>在<code>FDStackView</code>这里我们是通过<code>KVO</code>监测每一个<code>arrangedSubview</code>的<code>hidden</code>属性，当任何一个<code>arrangedSubview</code>属性发生变化后，我们就通过<code>rebuild</code>的方式重新创建整个<code>StackView</code>的约束，就是重新布局一遍。这是目前<code>1.0</code>版本的处理方式，这样势必会带来性能的损失，这也是我们后续优化性能的关键。</p>

<h3>子视图的<code>intrinsicContentSize</code>发生变化时如何处理</h3>

<p>什么叫子视图的<code>intrinsicContentSize</code>发生变化呢？举个例子，一个已经布好局的<code>StackView</code>，其中有一个<code>arrangedSubview</code>是一个<code>UILabel</code>，但是这个<code>UILabel</code>被重新<code>setText</code>了，那么它的<code>intrinsicContentSize</code>就会发生变化，自然<code>StackView</code>的布局如果不发生变化的话就是错误的。所以在这种情况下<code>StackView</code>也要做出处理。</p>

<p>这里我们研究了<code>UIStackView</code>的实现方式，一个<code>arrangedSubview</code>的<code>intrinsicContentSize</code>发生变化如何被捕捉到，是我们未知的，<code>UIKit</code>并没有暴露任何方法给我们，我们只能通过下符号断点的方式给dump出来的<code>UIStackView</code>的私有类。</p>

<p>研究发现当一个<code>arrangedSubview</code>的<code>intrinsicContentSize</code>发生变化时，<code>UIStackView</code>总会调用到<code>_intrinsicContentSizeInvalidatedForChildView:</code>这个私有方法，参数为发生变化的<code>arrangedSubview</code>。所以我们就把这一私有方法给替换了，借助<code>UIKit</code>内部的机制来帮我们通知一个<code>arrangedSubview</code>的<code>intrinsicContentSize</code>发生变化的这种情况。</p>

<p>{% codeblock lang:objc %}
// Use non-public API in UIView directly is dangerous, so we inject at runtime.
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        SEL selector = NSSelectorFromString(@&ldquo;_intrinsicContentSizeInvalidatedForChildView:&rdquo;);
        Method method = class_getInstanceMethod(self, @selector(intrinsicContentSizeInvalidatedForChildView:));
        class_addMethod(self, selector, method_getImplementation(method), method_getTypeEncoding(method));
    });
}
{% endcodeblock %}</p>

<p>接到这种通知之后，我们目前也是通过<code>rebuild</code>的方式来重建<code>StackView</code>的约束的。其实对于这种情况以及上面提到的<code>hidden</code>的情况，我们都能得到具体发生变化的那个<code>arrangedSubview</code>，这也将会是后续优化的突破口。</p>

<hr />

<p>到此整个<code>FDStackView</code>的设计实现过程都介绍完了，当然还有一些零零碎碎的点没有说，都在源码里了。后续版本会增加<code>Layout Margins</code>的支持，以及性能优化。</p>

<p>最后在附一张<code>UIStackView</code>及<code>FDStackView</code>在不同<code>iOS</code>系统上加载运行图：</p>

<p><img src="https://oac67o3cg.qnssl.com/1475116763.png" alt="" /></p>

<p>全文完，转载请注明出处，谢谢阅读。</p>

<p>————————————</p>

<p><img src="https://oac67o3cg.qnssl.com/1475114982.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FDStackView —— Downward Compatible UIStackView (Part 2)]]></title>
    <link href="http://blog.wtlucky.com/blog/2016/01/19/fdstackview-downward-compatible-uistackview-part-2/"/>
    <updated>2016-01-19T14:44:53+08:00</updated>
    <id>http://blog.wtlucky.com/blog/2016/01/19/fdstackview-downward-compatible-uistackview-part-2</id>
    <content type="html"><![CDATA[<p>写完了<code>Part 1</code>就被接踵而至的新项目和新版本忙的不可开交，转眼间一个季度就已经过去了，而这篇<code>Part 2</code>却迟迟还没有出现。实在是抱歉没有及时更新。不过有一个好消息就是<code>FDStackView</code>已经被使用在我们自己的项目中，并且我们的项目也已经经过了两个版本的迭代，<code>FDStackView</code>可以说还是相当稳定的，并且可以顺利的通过苹果的审核机制，对这方面有顾虑的小伙伴们可以放心大胆的使用了。同时我们也将它的版本号从<code>1.0-alpha</code>升级到<code>1.0</code>。在此感谢一下各位热心的小伙伴们在<code>Github</code>上提出的<code>issue</code>,以及着重感谢下<a href="http://weibo.com/ljc1986?is_all=1">@里脊串</a>对<code>FDStackView</code>的重度使用及提出的各种隐晦的<code>bug</code>。后续我们将会对性能的优化做出改进，以及对<code>Layout Margins</code>的支持。</p>

<p>回到主题，这篇文章主要介绍<code>StackView</code>的实现，即如何通过现有<code>AutoLayout</code>技术实现<code>StackView</code>这样的一个控件。这里说明一下，当初我们编写<code>FDStackView</code>的时候，<code>UIStackView</code>还没有支持<code>Layout Margins</code>，所以我们也没有添加<code>Layout Margins</code>的支持，不过目前的<code>iOS SDK</code>已经增加了这一部分的支持，所以在打开<code>layoutMarginsRelativeArrangement</code>属性的情况下，<code>StackView</code>创建出的约束会与我后面所介绍的内容有一些出入，不过问题不大，仅仅是部分约束的<code>firstItem</code>由<code>StackView</code>本身变成<code>UILayoutGuide</code>的区别。</p>

<p> 实现<code>StackView</code>主要包括这几个技术点：</p>

<ul>
<li><strong><code>alignment</code>和<code>distribution</code>的约束如何添加和管理；</strong></li>
<li><strong><code>spacing</code>和<code>distribution</code>的关系及约束的创建；</strong></li>
<li><strong>子视图的隐藏显示如何处理；</strong></li>
<li><strong>子视图的<code>intrinsicContentSize</code>发生变化时如何处理。</strong></li>
</ul>


<!-- More -->


<blockquote><p>我们对<code>UIStackView</code>进行了详细的研究，包括<code>dump</code>出所有<code>UIStackView</code>的相关私有类，各个类的方法，实例变量等。还需要添加符号断点来跟踪各个方法的调用顺序及各个实例变量的值得变化情况。同时还需要分析各个状态下<code>UIStackView</code>的约束<code>constraints</code>的情况，包括约束的个数，连接的方式，及约束所添加到的视图等。经过以上的各种分析之后，我们又通过在<code>IB</code>中借助<code>UIView</code>手动连接约束的方式，连出每一个<code>UIStackView</code>所对应的状态。经过这一番调查与研究我们已经大概摸清的<code>UIStackView</code>的工作原理与实现方式。</p></blockquote>

<p>如上篇文章所说，在进行了详尽的研究之后，总结出大概需要攻克的是这几个技术点，以尽可能的与<code>UIStackView</code>的实现保持一致，在难以完成的地方通过自己的方式实现。在这之前先介绍一下我们使用到的几个私有类。</p>

<h5><code>CATransformLayer</code></h5>

<p><code>StackView</code>是一个透明不可见的容器，主要就是因为这个<code>layer</code>，我们继承了它并重载了两个方法，<code>setOpaque:</code>和<code>setOpaque:</code>，用于避免产生警告⚠️。也就是项目中的<code>FDTransformLayer</code>。</p>

<h5><code>_UILayoutSpacer</code></h5>

<p>这是一个私有类，它的主要作用是用了辅助<code>StackView</code>创建<code>alignment</code>方向上的约束，它的父类是<code>UILayoutGuide</code>，并不是一个UIView的子类，所以我们并不能以熟悉的方式对它添加约束。但是在知道了它的作用之后，我们完全可以使用一个<code>UIView</code>来代替它，同时它也是不可见的，所以它的<code>layer</code>自然也是<code>FDTransformLayer</code>。这是项目中的<code>FDLayoutSpacer</code>。</p>

<h5><code>_UIOLAGapGuide</code></h5>

<p>与<code>_UILayoutSpacer</code>相同是<code>UILayoutGuide</code>的子类，用来辅助<code>distribution</code>方向上的约束创建，并且只有<code>UIStackViewDistributionEqualSpacing</code>和<code>UIStackViewDistributionEqualCentering</code>两种模式下它才会出现。在项目中我们通过<code>UIView</code>的子类<code>FDGapLayoutGuide</code>来实现它。</p>

<h5><code>_UILayoutArrangement</code></h5>

<p>同样是一个私有类，用来管理<code>StackView</code>及其子视图的约束的创建。它是一个父类，在<code>FDStackView</code>中我们使用<code>FDStackViewLayoutArrangement</code>来与之对应。</p>

<h5><code>_UIAlignedLayoutArrangement</code></h5>

<p>该类是<code>_UILayoutArrangement</code>的子类，用来控制<code>alignment</code>方向上的约束的创建及管理，它维护了一个<code>_UILayoutSpacer</code>并负责它的生命周期。在<code>FDStackView</code>中我们以更直接的<code>FDStackViewAlignmentLayoutArrangement</code>来对它命名。</p>

<h5><code>_UIOrderedLayoutArrangement</code></h5>

<p>与<code>_UIAlignedLayoutArrangement</code>相对，用来控制<code>distribution</code>方向上的约束创建及管理，它维护了一组<code>_UIOLAGapGuide</code>。在<code>FDStackView</code>中我们以更直接的<code>FDStackViewDistributionLayoutArrangement</code>来对它命名。</p>

<p>先提前解释几个后面会提到的名词：</p>

<ul>
<li><code>canvas</code> ：<code>canvas</code>是什么？翻译过来是画布的意思，其实就是容器也就是<code>StackView</code>本身</li>
<li><code>Ambiguity Suppression</code> ：经常<code>Debug``AutoLayout</code>的同学可能对这个词并木陌生，一般约束产生冲突或者模棱两可的时候，控制台就会输出一组信息，其中就会包含这个词。这里就是抵制模棱两可的约束的意思。<code>StackView</code>中会创建一些低优先级的约束来完成这件事儿，以防止控制台打出<code>AutoLayout</code>异常的<code>log</code>。</li>
<li><code>minAttribute</code> ：是<code>NSLayoutAttribute</code>一个便捷获取方式，针对不同的<code>axis</code>会对应不同的<code>NSLayoutAttribute</code>，可能是<code>NSLayoutAttributeTop</code>也可能是<code>NSLayoutAttributeLeading</code>。</li>
<li><code>centerAttribute</code> :同样针对不同的<code>axis</code>可能是<code>NSLayoutAttributeCenterY</code>或者<code>NSLayoutAttributeCenterX</code>。</li>
<li><code>maxAttribute</code> :同样针对不同的<code>axis</code>可能是<code>NSLayoutAttributeBottom</code>或者<code>NSLayoutAttributeTrailing</code>。</li>
<li><code>dimensionAttribute</code> :同样针对不同的<code>axis</code>可能是<code>NSLayoutAttributeHeight</code>或者<code>NSLayoutAttributeWidth</code>。</li>
</ul>


<p>{% codeblock FDStackViewAlignmentLayoutArrangement lang:objc %}
- (NSLayoutAttribute)minAttributeForCanvasConnections {
    return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeTop : NSLayoutAttributeLeading;
}</p>

<ul>
<li><p>(NSLayoutAttribute)centerAttributeForCanvasConnections {
  return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeCenterY : NSLayoutAttributeCenterX;
}</p></li>
<li><p>(NSLayoutAttribute)maxAttributeForCanvasConnections {
  return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeBottom : NSLayoutAttributeTrailing;
}</p></li>
<li><p>(NSLayoutAttribute)dimensionAttributeForCurrentAxis {
  return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeHeight : NSLayoutAttributeWidth;
}
{% endcodeblock %}</p></li>
</ul>


<p>{% codeblock FDStackViewAlignmentLayoutArrangement lang:objc %}
- (NSLayoutAttribute)minAttributeForCanvasConnections {
    return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeLeading : NSLayoutAttributeTop;
}</p>

<ul>
<li><p>(NSLayoutAttribute)centerAttributeForCanvasConnections {
      return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeCenterY : NSLayoutAttributeCenterX;
}</p></li>
<li><p>(NSLayoutAttribute)dimensionAttributeForCurrentAxis {
      return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeWidth : NSLayoutAttributeHeight;
}</p></li>
<li><p>(NSLayoutAttribute)minAttributeForGapConstraint {
  return self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeLeading : NSLayoutAttributeTop;
}
{% endcodeblock %}</p></li>
</ul>


<p>此外<code>UIStackView</code>的约束的管理方式也十分的奇妙。除了一个例外的<code>Ambiguity Suppression</code>的约束，其余不管约束何种关系的约束都是add在<code>canvas</code>上的。既然约束都加在了<code>canvas</code>上，那这么多的约束如何区分何管理呢？</p>

<p>这里有个小技巧，那就是用<code>weakToWeak</code>的<code>NSMapTable</code>来管理，<code>key</code>是约束的<code>firstItem</code>,<code>value</code>是约束，而且因为<code>NSMapTable</code>是<code>weakToWeak</code>的，所以<code>key</code>和<code>value</code>所对应的<code>object</code>并不会增加引用计数，不会带来内存上的管理困难。若要找一个<code>view</code>所关联约束，直接取<code>view</code>作为<code>key</code>的<code>value</code>就可以了。<code>_UILayoutArrangement</code>维护了多个这样的<code>NSMapTable</code>，分别来管理不同作用的约束。不得不说这样的设计真的是太巧妙了。</p>

<hr />

<h3><code>alignment</code>和<code>distribution</code>的约束如何添加和管理</h3>

<p>先给一张图看一下什么是<code>alignment</code>和<code>distribution</code>以及<code>Spacing</code>:</p>

<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/uistack_hero_2x_04e50947-5aa0-4403-825b-26ba4c1662bd.png" alt="image" /></p>

<p>在介绍实现之前，我先介绍一下<code>StackView</code>的各种<code>alignment</code>模式都是什么效果的：</p>

<ul>
<li><strong>UIStackViewAlignmentFill</strong>：这种就是填充满整个<code>StackView</code>了，用得比较多。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_fill_2x_8d71867d-e6cf-4063-b337-17dbc815c16e.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentLeading</strong>：这种是左对齐。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_leading_2x_bd31ee78-682d-4e36-990e-d655505fdc95.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentTop</strong>：这种是上部对齐。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_top_2x_bfa21a2d-1678-4b11-aa80-0750a4534bfc.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentFirstBaseline</strong>：这种是让<code>arrangedSubviews</code>按照<code>firstBaseline</code>对齐。只能出现在水平的<code>StackView</code>中。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_firstbaseline_2x_8b939a0f-5296-45d2-836c-aa05b4432e12.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentCenter</strong>：这种是居中对齐。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_center_2x_a34c8513-6f32-4cac-8149-4e4c1d206a3a.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentTrailing</strong>：这种是右部对齐。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_leading_2_2x_61cdf9c4-2a5b-4a3e-9c13-b0f1fa6bf348.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentBottom</strong>：这种是底部对齐。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_bottom_2x_2dc738dd-2d3a-4f7b-baee-aa283fe41e9f.png" alt="image" /></p>

<ul>
<li><strong>UIStackViewAlignmentLastBaseline</strong>：这种是让<code>arrangedSubviews</code>按照<code>lastBaseline</code>对齐。同样只能出现在水平的<code>StackView</code>中。</li>
</ul>


<p><img src="https://docs-assets.developer.apple.com/published/82128953f6/align_lastbaseline_2x_82af7014-4e27-450d-9115-b058217de073.png" alt="image" /></p>

<p>下面介绍实现，首先是<code>alignment</code>方向，<code>alignment</code>方向的约束主要包括4种
{% codeblock lang:objc %}
@interface FDStackViewAlignmentLayoutArrangement : FDStackViewLayoutArrangement
@property (nonatomic, strong) NSMutableArray<NSLayoutConstraint *> <em>canvasConnectionConstraints;
@property (nonatomic, strong) NSMapTable<UIView *, NSLayoutConstraint *> </em>hiddingDimensionConstraints;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSMapTable *> *alignmentConstraints;
@end</p>

<p>@interface FDLayoutSpacer : UIView
@property (nonatomic, strong, readonly) NSMutableArray<NSLayoutConstraint *> *systemConstraints;
@end</p>

<p>{% endcodeblock %}</p>

<ul>
<li><strong>canvasConnectionConstraints</strong>：它管理的是<code>arrangedSubviews</code>与<code>canvas</code>之间的约束；</li>
<li><strong>hiddingDimensionConstraints</strong>：它管理的是当<code>arrangedSubviews</code>有<code>hidden</code>的时候，该<code>arrangedSubview</code>的有关<code>dimensionAttribute</code>的约束；</li>
<li><strong>systemConstraints</strong>：它是由<code>_UILayoutSpacer</code>来管理的，它管理了spacer与<code>arrangedSubviews</code>之间的约束，因为这些约束的<code>firstItem</code>都是spacer自身，所以就不需要使用<code>NSMapTable</code>而直接是<code>NSArray</code>。另外spacer只有在<code>alignment</code>不是<code>UIStackViewAlignmentFill</code>的时候才会被创建，所以当<code>alignment</code>是<code>UIStackViewAlignmentFill</code>时，是没有<code>systemConstraints的</code>；</li>
<li><strong>alignmentConstraints</strong>：它管理的是<code>arrangedSubviews</code>之间的约束，它包括两组<code>NSMapTable</code>，根据<code>alignment</code>的不同具体的约束也不同，具体的<code>NSMapTable</code>的<code>key</code>与<code>alignment</code>及<code>axis</code>的关系如下表：</li>
</ul>


<p><img src="https://oac67o3cg.qnssl.com/1475116676.png" alt="" /></p>

<p>可以看到除了<code>UIStackViewAlignmentFill</code>模式以外，都会有一个<code>Ambiguity Suppression</code>的key，这个key对应的<code>NSMapTable</code>的就管理了前面提到的那些低优先级防止布局时出现模棱两可状态的约束。此外<code>Baseline</code>相关的约束是只有在<code>axis</code>为<code>Horizontal</code>时才会有的，并且<code>UIStackViewAlignmentFirstBaseline</code>和<code>UIStackViewAlignmentTop</code>，<code>UIStackViewAlignmentLastBaseline</code>和<code>UIStackViewAlignmentBottom</code>的key值是相同的。</p>

<p>这个key的名字之所以这么取也是有讲究的，它代表着它所对应的<code>NSMapTable</code>管理的约束关系。举个例子：<code>axis</code>为<code>Horizontal</code>，<code>alignment</code>为<code>UIStackViewAlignmentFill</code>时，key为<code>Top</code>和<code>Bottom</code>，那么<code>Top</code>对应的<code>NSMapTable</code>管理的约束就是<code>arrangedSubviews</code>之间<code>NSLayoutAttributeTop</code>相等的约束。同理<code>Bottom</code>就是<code>NSLayoutAttributeBottom</code>相等的约束。</p>

<p>这样结合<code>alignment</code>的效果来看就很容易理解，<code>UIStackViewAlignmentFill</code>模式需要<code>arrangedSubviews</code>都充满容器，那么自然他们的<code>NSLayoutAttributeTop</code>和<code>NSLayoutAttributeBottom</code>需要都相等，而<code>UIStackViewAlignmentTop</code>模式需要<code>top</code>对齐那么只需要<code>NSLayoutAttributeTop</code>相等就OK了。</p>

<p>这里还有一个点就是<code>arrangedSubviews</code>之间的约束不是迭代添加的，而是都与第一个<code>arrangedSubview</code>创建关系。假设有3个<code>view</code>，那就是<code>view2</code>与<code>view1</code>建立约束，<code>view3</code>同样与<code>view1</code>建立约束而不是与<code>view2</code>迭代建立约束。</p>

<p>这4种约束的创建顺序是：</p>

<ol>
<li><code>FDLayoutSpacer的systemConstraints</code></li>
<li><code>canvasConnectionConstraints</code></li>
<li><code>alignmentConstraints</code></li>
<li><code>hiddingDimensionConstraints</code></li>
</ol>


<p><code>FDLayoutSpacer的systemConstraints</code>在<code>FDStackViewAlignmentLayoutArrangement</code>中被称为<code>spanningLayoutGuideConstraints</code>，创建方法是
{% codeblock lang:objc %}
- (void)updateSpanningLayoutGuideConstraintsIfNecessary {
    if (self.mutableItems.count == 0) {
        return;
    }</p>

<pre><code>if (self.spanningLayoutGuide &amp;&amp; self.spanningGuideConstraintsNeedUpdate) {
    [self.canvas removeConstraints:self.spanningLayoutGuide.systemConstraints];
    [self.spanningLayoutGuide.systemConstraints removeAllObjects];

    //FDSV-spanning-fit
    NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:self.spanningLayoutGuide attribute:self.spanningLayoutGuide.isHorizontal ? NSLayoutAttributeWidth : NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:0];
    constraint.priority = 51;
    constraint.identifier = @"FDSV-spanning-fit";
    [self.canvas addConstraint:constraint];
    [self.spanningLayoutGuide.systemConstraints addObject:constraint];

    //FDSV-spanning-boundary
    [self.mutableItems enumerateObjectsUsingBlock:^(UIView *item, NSUInteger idx, BOOL *stop) {
        NSLayoutConstraint *minConstraint = [NSLayoutConstraint constraintWithItem:self.spanningLayoutGuide attribute:self.minAttributeForCanvasConnections relatedBy:[self layoutRelationForItemConnectionForAttribute:self.minAttributeForCanvasConnections] toItem:item attribute:self.minAttributeForCanvasConnections multiplier:1 constant:0];
        minConstraint.identifier = @"FDSV-spanning-boundary";
        minConstraint.priority = 999.5;
        [self.canvas addConstraint:minConstraint];
        [self.spanningLayoutGuide.systemConstraints addObject:minConstraint];

        NSLayoutConstraint *maxConstraint = [NSLayoutConstraint constraintWithItem:self.spanningLayoutGuide attribute:self.maxAttributeForCanvasConnections relatedBy:[self layoutRelationForItemConnectionForAttribute:self.maxAttributeForCanvasConnections] toItem:item attribute:self.maxAttributeForCanvasConnections multiplier:1 constant:0];
        maxConstraint.identifier = @"FDSV-spanning-boundary";
        maxConstraint.priority = 999.5;
        [self.canvas addConstraint:maxConstraint];
        [self.spanningLayoutGuide.systemConstraints addObject:maxConstraint];
    }];
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>首先判断一些不需要创建或者不需要更新这组约束的情况，比如之前提到的<code>alignment</code>为<code>UIStackViewAlignmentFill</code>或者没有<code>arrangedSubview</code>的时候。接下来创建一个宽或高为<code>0</code>的约束给spacer，因为对于后面添加的约束而言，spacer是缺少这样的一个约束以保证它能够正确布局。最后就是把每一个<code>arrangedSubview</code>与spacer分别建立<code>minAttribute</code>和<code>maxAttribute</code>的约束，这些约束的<code>constant</code>都是<code>0</code>，但是关系却不一定都是等于，需要根据<code>alignment</code>的属性不同来动态调整，有可能是大于等于，也有可能是小于等于。这需要查表来得到。</p>

<p>下一步创建<code>canvasConnectionConstraints</code>
{% codeblock lang:objc %}
- (void)updateCanvasConnectionConstraintsIfNecessary {
    if (self.mutableItems.count == 0) {
        return;
    }</p>

<pre><code>[self.canvas removeConstraints:self.canvasConnectionConstraints];
[self.canvasConnectionConstraints removeAllObjects];

NSArray&lt;NSNumber *&gt; *canvasAttributes = @[@(self.minAttributeForCanvasConnections), @(self.maxAttributeForCanvasConnections)];
if (self.alignment == UIStackViewAlignmentCenter) {
    canvasAttributes = [canvasAttributes arrayByAddingObject:@(self.centerAttributeForCanvasConnections)];
} else if (self.isBaselineAlignment) {
    NSLayoutConstraint *canvasFitConstraint = [NSLayoutConstraint constraintWithItem:self.canvas attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:0];
    canvasFitConstraint.identifier = @"FDSV-canvas-fit";
    canvasFitConstraint.priority = 49;
    [self.canvas addConstraint:canvasFitConstraint];
    [self.canvasConnectionConstraints addObject:canvasFitConstraint];
}

[canvasAttributes enumerateObjectsUsingBlock:^(NSNumber *canvasAttribute, NSUInteger idx, BOOL *stop) {
    NSLayoutAttribute attribute = canvasAttribute.integerValue;
    NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:[self viewOrGuideForLocationAttribute:attribute] attribute:attribute relatedBy:[self layoutRelationForCanvasConnectionForAttribute:attribute] toItem:self.canvas attribute:attribute multiplier:1 constant:0];
    constraint.identifier = @"FDSV-canvas-connection";
    [self.canvas addConstraint:constraint];
    [self.canvasConnectionConstraints addObject:constraint];
}];
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>因为这是<code>alignment</code>的<code>canvasConnectionConstraints</code>，所以只需关注它自己的<code>minAttribute</code>和<code>maxAttribute</code>两个方向与<code>canvas</code>的约束即可，其余两个方向会在<code>distributionLayoutArrangement</code>中创建。</p>

<p>特别的是如果<code>alignment</code>是<code>UIStackViewAlignmentCenter</code>的话需要加上一个<code>centerAttribute</code>的约束。如果是<code>alignment</code>是<code>baseline</code>相关的话还要给<code>canvas</code>添加一个高为<code>0</code>的低优先级约束，用来满足某些特殊情况下<code>canvas</code>约束不满足的情况。</p>

<p>具体与<code>canvas</code>建立约束关系的<code>firstItem</code>及<code>relation</code>关系是根据<code>alignment</code>类型以及<code>NSLayoutAttribute</code>的不同而不同的，情况比较多我就不一一列举了，同样是根据查表得到，具体可以看代码去查。</p>

<p>最后是<code>alignmentConstraints</code>和<code>hiddingDimensionConstraints</code>，虽然前面说它们两个的顺序是一前一后创建，但其实并不是，它们可以说是一起创建的，首先取出第一个<code>arrangedSubview</code>作为<code>guardView</code>，然后循环遍历其余<code>arrangedSubview</code>，先添加<code>alignmentConstraint</code>，如果这个<code>arrangedSubview</code>是<code>hidden</code>的那么就会再添加一个<code>hiddingDimensionConstraint</code>。
{% codeblock lang:objc %}
- (void)updateAlignmentItemsConstraintsIfNecessary {
    if (self.mutableItems.count == 0) {
        return;
    }</p>

<pre><code>[self.alignmentConstraints setObject:[NSMapTable weakToWeakObjectsMapTable] forKey:self.alignmentConstraintsFirstKey];
[self.alignmentConstraints setObject:[NSMapTable weakToWeakObjectsMapTable] forKey:self.alignmentConstraintsSecondKey];
[self.canvas removeConstraints:self.hiddingDimensionConstraints.fd_allObjects];
[self.hiddingDimensionConstraints removeAllObjects];

UIView *guardView = self.mutableItems.firstObject;
[self.mutableItems enumerateObjectsUsingBlock:^(UIView *item, NSUInteger idx, BOOL *stop) {
    if (self.alignment != UIStackViewAlignmentFill) {
        NSLayoutConstraint *ambiguitySuppressionConstraint = [NSLayoutConstraint constraintWithItem:item attribute:self.alignmentConstraintsFirstAttribute relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:0];
        ambiguitySuppressionConstraint.identifier = @"FDSV-ambiguity-suppression";
        ambiguitySuppressionConstraint.priority = 25;
        [item addConstraint:ambiguitySuppressionConstraint];
        [self.alignmentConstraints[self.alignmentConstraintsFirstKey] setObject:ambiguitySuppressionConstraint forKey:item];
    } else {
        if (item != guardView) {
            NSLayoutConstraint *firstConstraint = [NSLayoutConstraint constraintWithItem:guardView attribute:self.alignmentConstraintsFirstAttribute relatedBy:NSLayoutRelationEqual toItem:item attribute:self.alignmentConstraintsFirstAttribute multiplier:1 constant:0];
            firstConstraint.identifier = @"FDSV-alignment";
            [self.canvas addConstraint:firstConstraint];
            [self.alignmentConstraints[self.alignmentConstraintsFirstKey] setObject:firstConstraint forKey:item];
        }
    }
    if (item != guardView) {
        NSLayoutConstraint *secondConstraint = [NSLayoutConstraint constraintWithItem:guardView attribute:self.alignmentConstraintsSecondAttribute relatedBy:NSLayoutRelationEqual toItem:item attribute:self.alignmentConstraintsSecondAttribute multiplier:1 constant:0];
        secondConstraint.identifier = @"FDSV-alignment";
        [self.canvas addConstraint:secondConstraint];
        [self.alignmentConstraints[self.alignmentConstraintsSecondKey] setObject:secondConstraint forKey:item];
    }
    if (item.hidden) {
        NSLayoutConstraint *hiddenConstraint = [NSLayoutConstraint constraintWithItem:item attribute:self.axis == UILayoutConstraintAxisHorizontal ? NSLayoutAttributeHeight : NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:0];
        hiddenConstraint.priority = [item contentCompressionResistancePriorityForAxis:self.axis == UILayoutConstraintAxisHorizontal ? UILayoutConstraintAxisVertical : UILayoutConstraintAxisHorizontal];
        hiddenConstraint.identifier = @"FDSV-hiding";
        [self.canvas addConstraint:hiddenConstraint];
        [self.hiddingDimensionConstraints setObject:hiddenConstraint forKey:item];
    }
}];
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这里的<code>alignmentConstraint</code>的创建都是<code>guardView</code>与其余的<code>arrangedSubview</code>创建<code>relation</code>关系为<strong>相等</strong>的约束，而<code>NSLayoutAttribute</code>的选择仍然是查表法，根据<code>axis</code>和<code>alignment</code>的不同而选择不同的<code>NSLayoutAttribute</code>。</p>

<p>如果<code>alignment</code>不是<code>UIStackViewAlignmentFill</code>模式的话，就会给<code>arrangedSubview</code>创建一个<code>dimensionAttribute</code>为<code>0</code>的低优先级约束，称为<code>ambiguitySuppressionConstraint</code>放在上图中<code>key</code>为<code>Ambiguity Suppression</code>的<code>NSMapTable</code>中。</p>

<hr />

<p>现在解释一下<a href="http://blog.wtlucky.com/blog/2015/10/09/fdstackview-downward-compatible-uistackview-part-1/">本文章<code>Part 1</code></a>中最后提到的<code>UIStackView</code>当<code>alignment</code>为<code>UIStackViewAlignmentFill</code>时，最高视图隐藏掉，而其余视图没有变成第二个的视图的高度的<code>bug</code>。原因就是在<code>UIStackView</code>的中实现中<code>AlignmentLayoutArrangement</code>是没有管理<code>hiddingDimensionConstraints</code>的，所以当视图被隐藏了后，那个视图被添加了一个宽为<code>0</code>的约束，视觉上看不到了，但是高方向的约束仍然存在，所以仍然会撑开<code>StackView</code>，所以在<code>FDStackView</code>中我们在<code>alignment</code>方向上同时增加了<code>hiddingDimensionConstraints</code>，视图被<code>hidden</code>后，会在高度方向上也给他加上一个高<code>0</code>为的约束，而且这个优先级也很有讲究需要跟它的<code>contentCompressionResistancePriority</code>设为一样，这样才不会在<code>AutoLayout</code>布局系统中当用户人为添加一个高度约束后产生冲突。</p>

<p>写了这么多，才写完第一个技术点的第一部分，内容确实比较多，我写的也比较乱，时间比较紧所以写作时间是间断的，所以思维也是间断跳跃的，还麻烦各位看官多多包涵。本来打算一篇写完的，但是这么长，还是有必要在分一下的，<code>Part 2</code>就到这吧，其余的内容就在<code>Part 3</code>吧。</p>

<p>————————————</p>

<p><img src="https://oac67o3cg.qnssl.com/1475114982.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
